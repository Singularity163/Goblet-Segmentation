import numpy as np
import pandas as pd
from skimage.measure import label, regionprops_table

_PIXEL_PIXEL_PROPS = [
    "area",
]

_PIXEL_PROPS = [
    "perimeter",
    "axis_major_length",
    "axis_minor_length",
]

_MEASURED_PROPS = _PIXEL_PIXEL_PROPS + _PIXEL_PROPS

_RATIO_PROPS = [
    "eccentricity",
    "solidity",
    "orientation",
]

PROPERTIES = _MEASURED_PROPS + _RATIO_PROPS


def get_prop(binary_mask: np.ndarray, properties: list = PROPERTIES):
    """
    Gets the properties of the binary masks.

    Parameters:
    -----------
    binary_mask: np.ndarray
        2D binary masks.

    properties: list
        a collection of properties that is made available by
        `skimage.measure.regionprops`.

    Returns:
    --------
        pd.DataFrame of values representing each image as a row
        and designated properties as columns.

    Assuming we have .tiff we can convert the resolution to length.

    Example usage:
    >>> from PIL import Image
    >>> img = Image.open("image.tiff")
    >>> res_x, res_y = img.info.get("resolution", (None, None))

    >>> if not res_x or not res_y:
        # Can be handled by default parameters as well...but assume
    >>>     logging.error("Resolution not found, skipping image...")

    >>> binary_masks = ...
    >>> a_random_prop = get_prop(binary_masks[5])

    >>> area = a_random_prop["area"] * res_x * res_y

    >>> orientation = a_random_prop["orientation"]
    >>> axis_major_length = np.linalg.norm([
        a_random_prop["axis_major_length"] * np.cos(orientation) * res_x,
        a_random_prop["axis_major_length"] * np.sin(orientation) * res_y,
    ])
    """
    labels = label(binary_mask)
    props = regionprops_table(labels, properties=properties)
    df = pd.DataFrame(props)

    # Return the largest mask in case of artifacts
    if not df.empty:
        i_max = df["area"].idxmax()
        return df.loc[i_max]
    else:
        return pd.Series()


def analyze_properties(property_df: pd.DataFrame, resolution: float):
    """
    To be used in conjunction with `get_prop`. This method converts the values in the
    `property_df` into measured units given by `resolution`.

    Note: currently assumes that `property_df` is using the default `properties` list.
        This method also assumes that `resolution` in the x and y directions are the same.

    Parameters:
    -----------
    property_df: pd.DataFrame
        a dataframe containing properties generated by `get_prop`

    resolution: float
        the resolution in 1 measurement unit per pixel.

    Returns:
    --------
    pd.DataFrame:
        converted into measured units.
    """
    df = property_df.copy()

    # Convert unit pixel^2 to unit measurement^2
    df[_PIXEL_PIXEL_PROPS] = df[_PIXEL_PIXEL_PROPS] * (resolution**2)

    # Convert unit pixel to unit measurement
    df[_PIXEL_PROPS] = df[_PIXEL_PROPS] * resolution

    return df


def detect_outliers(data: pd.Series, thresh: int = 3, b: float = 1.4826):
    """Uses MAD as a method for outlier detection`.

    Developer Note: other implementations could work. Suggestion for
    future implementation can be found in `sklearn`.

    Adapted from https://doi.org/10.1016/j.jesp.2013.03.013

    Parameters:
    -----------
    data: pd.Series()
        a one-dimensional dataset that contains some information about the data.

    thresh: float
        the multiplicative constant mad thresholds.

    b: float
        Constant value for norm dist calibration.

    Returns:
    --------
    np.array[bool]:
        describes whether it is likely outlier (1) or not (0), respectively.
    """
    if len(data) <= 1:
        # Return the entire DataFrame as inliers if there's only one or no data points
        return data, pd.DataFrame()
    diffs = np.abs(data - data.median())
    mad = b * diffs.median()
    outliers = (diffs > thresh * mad).astype(int)
    outliers.name = "potential_outlier"
    return outliers
